<HTML>
<HEAD>
<TITLE>lc_intro.scm.html</TITLE>
</HEAD>
<BODY BGcolor=#FFFFFF TEXT=#000000>
<PRE>
<FONT color=#0000ff>; Lambda Calculus</FONT>
<FONT color=#0000ff>; ---------------</FONT>

<FONT color=#0000ff>; Lambda Calculus is a form of programming in which there are two basic</FONT>
<FONT color=#0000ff>; operations:</FONT>
<FONT color=#0000ff>; 1. Defining a function that accepts one argument and returns one argument.</FONT>
<FONT color=#0000ff>;    Markup: [lambda][variable].[return expression]</FONT>
<FONT color=#0000ff>; 2. Executing a lambda expression on another lambda expression:</FONT>
<FONT color=#0000ff>;    Markup: ([function] [argument])</FONT>

<FONT color=#0000ff>; Examples:</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> identity <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>a<FONT color=#6a5acd>)</FONT> a<FONT color=#6a5acd>))</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> second-argument <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>a<FONT color=#6a5acd>)</FONT> <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>b<FONT color=#6a5acd>)</FONT> <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>c<FONT color=#6a5acd>)</FONT> b<FONT color=#6a5acd>))))</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> another-example <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>f<FONT color=#6a5acd>)</FONT> <FONT color=#6a5acd>(</FONT>f f<FONT color=#6a5acd>)))</FONT>

<FONT color=#0000ff>; Note that as in Scheme, the returned lambdas remember all the variables</FONT>
<FONT color=#0000ff>; with which they were called. So for example:</FONT>
<FONT color=#6a5acd>(((</FONT>second-argument <FONT color=#ff00ff>5</FONT><FONT color=#6a5acd>)</FONT> <FONT color=#ff00ff>6</FONT><FONT color=#6a5acd>)</FONT> <FONT color=#ff00ff>7</FONT><FONT color=#6a5acd>)</FONT>
<FONT color=#0000ff>; Will propagate into:</FONT>
<FONT color=#0000ff>; (lambda (b) (lambda (c) b)) while remembering that a = 5</FONT>
<FONT color=#0000ff>; And in turn into</FONT>
<FONT color=#0000ff>; (lambda (c) b) while remembering that a = 5 and b = 6</FONT>
<FONT color=#0000ff>; And into</FONT>
<FONT color=#0000ff>; b while remembering that a = 5 and b = 6 and c = 7</FONT>
<FONT color=#0000ff>; Which is in turn equal to 6</FONT>


<FONT color=#0000ff>; Currying:</FONT>
<FONT color=#0000ff>; ---------</FONT>
<FONT color=#0000ff>;</FONT>
<FONT color=#0000ff>; We can create functions of more than one argument in Lambda Calculus </FONT>
<FONT color=#0000ff>; using a technique called Currying. What it means is that instead of having</FONT>
<FONT color=#0000ff>; one function that accepts several arguments, we have several nested </FONT>
<FONT color=#0000ff>; lambdas.</FONT>
<FONT color=#0000ff>;</FONT>
<FONT color=#0000ff>; Here's an example:</FONT>
<FONT color=#0000ff>;</FONT>
<FONT color=#0000ff>; Instead of writing:</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> my-func 
    <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>x y<FONT color=#6a5acd>)</FONT> 
        <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>+</FONT> <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>*</FONT> <FONT color=#ff00ff>2</FONT> x<FONT color=#6a5acd>)</FONT> <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>*</FONT> <FONT color=#ff00ff>3</FONT> y<FONT color=#6a5acd>))</FONT>
    <FONT color=#6a5acd>)</FONT>
<FONT color=#6a5acd>)</FONT>

<FONT color=#0000ff>; and invoking it with</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> ret <FONT color=#6a5acd>(</FONT>my-func <FONT color=#ff00ff>5</FONT> <FONT color=#ff00ff>6</FONT><FONT color=#6a5acd>))</FONT>

<FONT color=#0000ff>; We can define:</FONT>

<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> my-func
    <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>x<FONT color=#6a5acd>)</FONT>
        <FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>lambda</FONT></B> <FONT color=#6a5acd>(</FONT>y<FONT color=#6a5acd>)</FONT>
            <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>+</FONT> <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>*</FONT> <FONT color=#ff00ff>2</FONT> x<FONT color=#6a5acd>)</FONT> <FONT color=#6a5acd>(</FONT><FONT color=#008b8b>*</FONT> <FONT color=#ff00ff>3</FONT> y<FONT color=#6a5acd>))</FONT>
        <FONT color=#6a5acd>)</FONT>
    <FONT color=#6a5acd>)</FONT>
<FONT color=#6a5acd>)</FONT>

<FONT color=#0000ff>; and invoke it with</FONT>
<FONT color=#6a5acd>(</FONT><B><FONT color=#a52a2a>define</FONT></B> ret <FONT color=#6a5acd>((</FONT>my-func <FONT color=#ff00ff>5</FONT><FONT color=#6a5acd>)</FONT> <FONT color=#ff00ff>6</FONT><FONT color=#6a5acd>))</FONT>

<FONT color=#0000ff>; I.e: by making one function call for every argument.</FONT>

<FONT color=#0000ff>; This technique simplifies the lambda calculus grammar and allows</FONT>
<FONT color=#0000ff>; us to only deal with functions (and function calls) of one argument</FONT>


</PRE>
</BODY>
</HTML>
