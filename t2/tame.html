<body dir=rtl>

<h2>כמה עיניים צריך כדי להשתלט על מורכבות ?</h2>

<p>
להבחין בגדול שסגנון הבזאר מאיץ את זמן ניפוי השגיאות והתפתחות הקוד הוא דבר אחד. דבר אחר הוא להבין בדיוק למה ואיך הוא עושה
זאת ברמת המיקרו של ההתנהגות היום יומית של המפתח. בחלק זה (שנכתב שלוש שנים לאחר הפצת המסמך המקורי, תוך שימוש בראיות שונות
של מפתחים שקראו אותו ובחנו מחדש את התנהגותם) ניקח מבט מקרוב על מה שבאמת קורה שם. קוראים לא-טכניים יכולים לדלג בביטחה
לחלק הבא.

<p>
מפתח אחד להבנה הוא להפנים מדוע בדיוק משתמשים שלא מודעים לקוד המקור נוטים להיות לא ממש לעזר. משתמשים שלא מודעים לקוד המקור
נוטים לדווח אך ורק על סימפטומים שטחיים; הם לוקחים את סביבתם כמובן מאליו, לכן הם (א) מתעלמים ממידע סביבתי חשוב (ב) לעיתים
רחוקות נוטים לכלול "מרשם" אמין על מנת לראות איך "להפעיל" את הבאג.

<p>
הבעיה היסודית כאן היא חוסר התאמה בין המודל הרוחני של המפתח לבין המודל הרוחני של הבוחן; הבוחן, מבחוץ מסתכל פנימה, והמפתח
מבפנים מביט החוצה. במודל הפיתוח של הקוד הסגור שניהם תקועים בתפקידים אלו, ונוטים לדבר אחד אל השני ומוצאים את עצמם מתוסכלים.

<p>
מודל הקוד הפתוח שובר את הקשר הזה, ומפשט הן למפתח והן לבוחן לפתח ייצוג משותף שמבוסס על הקוד האמיתי ולתקשר ביתר קלות וביעילות.
מעשית, ישנו שוני כביר בין דיווח באגים שמדווח על סימפטומים שברורים לעין חיצונית לבין דיווח הבאגים שניגש ישר לקוד המקור של התוכנית.

<p>
רוב הבאגים, רוב הזמן, מתגלים בקלות אפילו אם נתון תיאור לוקה בחסר אך גם מרמז של תנאי השגיאה ברמת קוד המקור. כאשר מישהו מבין
מבוחני התוכנה שלך יכול לומר: "ישנה טעות בשורה <em>nnn</em>" או אפילו רק "תחת תנאים X, Y ו- Z המשתנה הזה מתהפך", מבט חטוף
על הקוד הבעייתי לעיתים קרובות מספיק לזהות במדוייק את המצב מדוייק של השגיאה ולייצר תיקון.

<p>
לכן, מודעות קוד המקור הפתוח משני הצדדים מגבירה במידה עצומה גם תקשורת טובה בין הצדדים וגם שיתוף הפעולה בין מה שבוחן מדווח לבין מה שהמפתח(ים) המרכזי יודע. זה אומר שזמן המפתח נוטה להיות משומר מאוד, אפילו עם משתפי פעולה רבים.

<p>
מאפיין אחר של שיטת הקוד הפתוח שמשמר את זמן המפתח הוא מבנה התקשורת של פרוייקטים בשיטת קוד מקור פתוח אופייניים. מעל
השתמשתי במונח "מפתח מרכזי"; מונח זה משקף שוני בין ליבת הפרוייקט (די קטן; מפתח יחיד הוא די מצוי, ובין מפתח אחד לשלושה
טיפוסי) לבין הילת הפרוייקט של בוחני התוכנה ותורמים זמינים (שלעיתים נספרים במאות).

<p>
הבעייה היסודית שאירגוני מפתחי תוכנה מסורתיים נתקלים בה היא חוקו של ברוקס: "הוספת יותר מפתחים בשלב מאוחר הופכת את הפרוייקט
למאוחר". בכלליות חוקו של ברוקס מנבא שהמורכבות ומחיר התקשורת של פרוייקט עולים ככל שמספר המפתחים גודל, כאשר עבודה גמורה
צומחת באופן ליניארי בלבד.

<p>
חוקו של ברוקס נוסד על פי ניסיון שבאגים נוטים להתקבץ בממשקים בין קוד שנכתב בין אנשים שונים ושתקשורת/קוארדינציה בשמים
נוטים לגדול עם מספר הממשקים בין אנשים. לכן בעיות גוברות עם מספר מסלולי התקשורת בין מפתחים, שגוברות לפי ריבוע מספר המפתחים
(בדיוק יתר, לפי הנוסחה N*(N-1)/2 כאשר N הוא מספר המפתחים).

<p>
ניתוח חוקו של ברוקס (ותוצאת הפחד של מספר אנשים גדול בקבוצות פיתוח) מתבסס על ההנחה: שמבנה התקשורת של הפרוייקט הוא בהכרח תרשים
שלם, שכולם מדברים אל כולם. אולם בפרוייקטי קוד-פתוח, מתכנתי המעטפת עובדים על מה שהם למעשה תת-משימות מקבילות וניתנות להפרדה
והאינטרקציה ביניהם מואטת מאוד.

<p>
עדיין ישנן עוד סיבות שדיווח באגים ברמת קוד המקור נוטה להיות די יעיל. הן מתרכזות סביב העובדה ששגיאה אחת לעיתים קרובות
יכולה להיגרם על ידי מספר סימפטומים, שמוכיחה אחרת תלוי בפרטים של דפוס שימוש המשתמש והסביבה. שגיאות כאלו נוטות להיות בדיוק
הסוג של באגים מסובכים ודקים (כגון שגיאות ניהול-זיכרון-דינמי) שהם הקשים לתפיסה לפי רצון או לזהות במדוייק לפי ניתוח סטטי, ואלו
שגורמים הכי הרבה לבעיות ארוכות-טווח בתוכניות.

<p>
בוחן שמגיש תיאור ברמת קוד-מקור של מולטי-סימפטום כזה או אחר (כגון: "נראה לי שיש חלון בטיפול הסיגנלים ליד שורה 1250" או
"היכן אתה מאפס את מאגר ?") ייתכן וייתן למפתח את הרמז הגורלי לחצי תריסר סימפטומים שונים לגמרי. במקרים כאלו, יהיה קשה ואפילו
בלתי-אפשרי כדי לדעת איזו "התנהגות בלתי הולמת" שנראית לעין נגרמה על ידי בדיוק איזה באג - אך עם הפצות מהירות, זה לא חיוני.
קרוב לוודאי שמשתפי פעולה אחרים ימצאו האם הבאג תוקן או לא במהירות. במקרים רבים דיווחי-באגים ברמת קוד-מקור יגרמו ל"התנהגות
הבלתי הולמת" מצד התוכנה ל"התסלק" אפילו ללא כתיבת תיקון כלשהו.

<p>
מולטי-סימפטומים מסובכים גם נוטים לכלול נתיבי איתור רבים, מסימפטומים שטחיים עד בחזרה לבאג הממשי. אילו מהנתיבים שהמפתח/בוחן
יכול לעבוד עליהם תלוי בשנינות של סביבתו של אדם זה, ויכול להשתנות בצורה לא ברורה ממש עם הזמן. כתוצאה, כל אחד מן המפתחים
והבוחנים "דוגם" חלק "חצי-אקראי" מן התוכנית כאשר הוא מחפש את סיבת השגיאה. ככל שהבאג דק ומסובך, פחות סביר להניח שניסיון יוכל
לערוב לשייכות של אותה הדגימה.

<p>
עבור באגים שאפשר לייצרם בשנית בקלות, אז הדגש יהיה על "חצי" מאשר על "אקראי"; כישרון ניפוי השגיאות והקירבה העמוקה עם הקוד
והארכיקטורה שלו תהיה משמעותית מאוד. אך עבור באגים מורכבים, הדגש יהיה על ה"אקראי". תחת נסיבות אלו אנשים רבים שיריצו "מעקבים"
אחר התוכנית יהיו יותר יעילים בהרבה מאשר מספר אנשים שמריצים "מעקבים" בו זמנית - אפילו אם למעטים יש ניסיון רב יותר.

<p>
השפעה זו תוגבר בהרבה אם הקושי של עקיבת מסלולי איתור מתסמינים שטחיים בחזרה לבאג שמשתנה באופן משמעותי בדרך שלא תוכל להתנבא 
על ידי מבט על הסימפטומים. יהיה יותר סביר שמפתח יחיד שדוגם את הנתיבים הללו ברצף יבחר נתיב מסובך יותר בניסיון הראשון.
מצד שני, נניח שאנשים רבים מנסים נתיבי איתור במקביל בזמן שמשחררים הפצות מהירות. אז סביר יותר שאחד מהם ימצא את הנתיב מיד, 
ויתפוס את הבאג בזמן קצר יותר בהרבה. מתחזק הפרוייקט יראה שלשחרר הפצה, בזמן שאנשים רבים אחרים מריצים מעקבים על אותו הבאג יוכל
לעצור אותו לפני שיבזבז זמן רב מדי יותר על מעקבים קשים [RJ].