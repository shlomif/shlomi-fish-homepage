http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/intro.html :

מצגת זאת תציג מספר הרגלי הנדסת תוכנה טובים באופן מרוכז. אנו נסביר את
המוטיבציות לשימוש בהם, ונראה כיצד ניתן להתחיל להשתמש בהם באמצעות הדגמות
של התנסות מעשית (hands-on).

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/ :

בדיקות אוטומוטיות הן שיטה בהנדסת תוכנה שבמסגרתה כותבים פיסות קוד שמוודאות
שקוד הייצור (הקוד שמבצע את הפונקציונליות שבה אנו מעוניינים) פועל
בצורה נכונה.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/motivation.html :

למה אנו מעוניינים לכתוב בדיקות אוטומטיות?

1. כדי למנוע באגים. על-ידי כתיבת בדיקות לפני קוד הייצור אנו מוודאים שהוא מתנהג
בהתאם למה שהם מתארים.

2. כדי לוודא שבאגים ונסיגות לאחור ("רגרסיות") לא יצוצו מחדש בקוד.
    - נכתוב בדיקה שבודקת שהבאג לא נמצא, נראה שהיא נכשלת, ורק אז נתקן את הקוד.
    נוכל להריץ את הבדיקה על בסיס-הקוד הנוכחי גם בעתיד כדי לוודא שהבאג לא
    יצוץ (ובכלל זה לעיתים עם שינוי אדרת).

3. על ידי כתיבת בדיקות, אנו מספקים מפרט לקוד, ואפילו סוג מסוים של תיעוד
ממשק המתכנת (API), וכן דוגמאות למה שאנו רוצים שהקוד ישיג.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/demo/ :

אנו רוצים לבדוק פונקציה שמחברת שני מספרים.

דרך אחת לכתוב תסריט בסיסי שבודק אותה, היא כך.

הוא יזרק חריגה אם ביצוע חיבור של 2+2 נכשל, ויצא בהצלחה אם הכל בסדר.

הכל בסדר, אז הבה נכתוב בדיקה נוספת.

הפעם זה נכשל.

בעקבות זאת, אנו צריכים לתקן את קוד הייצור.

והתסריט המתאים מצליח.


http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/demo/test-more.html :

המודול Test::More כלול בפרל, שמאפשר לכתוב ולהריץ בדיקות אוטומטיות באמצעות שגרות שהשימוש בהן
הוא נוח. הנה דוגמה לתסריט בדיקות.

השגרה is() משווה את התוצאה שהתקבלה לתוצאה שאנו מצפים לה (באמצעות eq). יש גם
את ok() שרק בודקת את אמיתות הערך, is_deeply() שמבצעת השוואה עמוקה של מבני
נתונים מקוננים, ושגרות אחרות.

ייתכן שגם שמתם לב להערות הסולמית-TEST. אלה הינן הערות צד של ‎Test::Count שמאפשרות
לנו לעקוב אחרי מספר הצהרות הבדיקה שהגדרנו ולעדכן אותו בראש הקובץ.

הפלט יהיה:

זהו תסדיר פלט הנקרא TAP (פרוטוקול לבדוק הכל). ישנם מספר מנתחי TAP שמנתחים את הפלט
ומציגים את התוצאה. למשל נוכל להריץ את תסריט הבדיקה באמצעות התוכנית prove שמופצת
כחלק מפרל:

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/types.html :

ישנם מספר סוגי בדיקות: בדיקות יחידה, בדיקות מערכת, ובדיקות אינטגרציה.

בדיקות עשן - לראות מייד ומהר אם התוכנה מתפקדת באופן בסיסי. (מה שיצדיק ביצוע בדיקות
יותר מקיפות.)

שימוש בפרל כדי לבדוק קוד של שפות תכנות אחרות:

ניתן לעשות בה שימוש:

ראה את הדרכים השונות כדי להריץ תוכניות שורות פקודה ואת יכולות הסוקטים והרישות שלה.

לבדיקת ממשק משתמש גרפי, ראו את Win32-GuiTest ו-X11-GUITest

ניתן לעשות שימוש במשפחת המודולים Inline כדי להתממשק לקוד בשפות אחרות ישירות.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/testing/mocking.html :

חיקוי: כאשר בודקים חלקים מסוימים במערכת לפעמים זה רצוי להחליף חלקים אחרים
שבהם נעשה שימוש בחלקים משלנו המתנהגים כמותם לצרכי הבדיקות. לדוגמה כאשר בודקים
תסריט של שרת ווב, ייתכן שנרצה לחקות את השרת.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/version-control/ :

מערכות ניהול גרסאות נחשבות חלק "ממערכות בקרת תצורה" (SCM). הן מאפשרות לשמור
גרסאות הסטוריות של הקוד, לגשת אליהן בקלות, ולבצע פעולות נוספות כמו ניהול
ענפים ותוויות.

חלק זה בהרצאה יתן את המוטיבציה לשימוש בניהול גרסאות ויערוך הדגמה קצרה
באמצעות מערכת ניהול הגרסאות מרקוריאל.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/version-control/motivation.html :

היתרונות של שימוש במערכת ניהול גרסאות:

הקוד לא ילך לאיבוד בטעות, מפני שכל ההסטוריה שלו נשמרת בשירות ניהול גרסאות
מרוחק, ולכל המתכנתים יש עותק משלהם.

היא מאפשרת לשמור גרסאות הסטוריות של הקוד מה שמקל על חזרה למצב קודם, השוואה,
ומחקר. נניח הוכנס באג - ניתן לחזור לגרסה קודמת ולראות אם הוא שם, ואם לא להשוות
או לחזור לאחור.

היא מאפשרת לתחזק מספר ענפים של הקוד ולהשוות ביניהם ולאחות את השינויים מענף לענף
בקלות.

לבסוף, קרוב לודאי שתמצאו את השימוש במערכת ניהול גרסאות מודרנית ואיכותית, כפתרון
יותר נוח ועמיד מאשר שימוש בקבצי ארכיון וטלאים. יש מספר רב של מערכות ניהול גרסאות
פתוחות-קוד וחינמיות שאיכותן טובה וקרוב לודאי שתמצאו אחת שתאהבו.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/version-control/mercurial-demo.html :
st
הדגמה.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/accessors/ :

שיטות גישה ("נגשים"? אקססורים) - הן דרך לבצע אבסטרקציה לגישה של הגישה לשדות
של עצמים, מאחורי קריאות לשיטות/מתודות. לדוגמה, אנו יכולים לקרוא 
ל- ‪$person->age()‬ כדי לקרוא את גילו של ‪$person‬ ול-‪$person->age(21)‬
או ‪$person->set_age(21)‬ כדי לשנות את ערך הגיל שלהם ל-21.

לאקססורים יש מספר יתרונות חשובים על פני גישה לשדות של עצמים
באופן ישיר.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/accessors/example.html :

זוהי מחלקה לדוגמה עם מספר אקססורים ותסריט שמשתמש בה.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/accessors/motivation.html :

מוטיבציה: אז מדוע כדאי שנשתמש באקססורים במקום שנעשה גישה ישירה
ל-‪$person->{'age'}‬ לשדה של העצם?

1. כתיבת שמות השדות באופן ישיר בכל פעם מועד לטעויות כתיב ושגיאות.
לעומת זאת, בקריאה לשיטות/מתודות אז פרל תזרוק חריגה בזמן ריצה במקרה
שהשיטה לא קיימת.

2. אם יש צורך להמיר את השדה משדה לערך מחושב, אז עדיין ניתן להשתמש
במתודה/שיטה הקיימת כדי לספק גישה אליו, רק על ידי שינוי המימוש שלו.

3. הממשק החיצוני שמסופק על-ידי שיטות/מתודות נקי יותר וקל יותר לתחזוקה
של תאימות לאחור מאשר גישה ישירה לשדות של העצם.

4. ייתכנו גם סיבות אחרות, כמו מיקבול יותר טוב, התמדה (persistence) וכו.

http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/accessors/cpan-modules.html :

כתיבת אקססורים באופן ישיר ביד דורש קוד כפול רב ועלול להיות מלאה. אף
שניתן להתגבר על כך על-ידי שימוש במשחקי מרחבי-שמות, ישנם מודולים רבים
שעושים את זה בשבילך ובקלות:

1. המודול Class-Accessor - אחד הראשונים ועדיין פופולרי. כתוב בפרל טהור
ואין לו תלויות.

2. המודול Class-XSAccessor - כתוב חלקית בסי וב-XS והוא מהיר מאוד. השיטות
שהוא מייצר יותר מהירות מכתיבת אקססורים ביד כפי שהראנו.

3. מערכת האובייקטים Moose ־ מקיף מאוד ומספק דברים רבים מלבד אקססורים.



